<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Product Invented Chess</title>
  <style>
    /* Basic styling similar to your Python game window */
    body {
      margin: 0; padding: 0; 
      background: #fff; 
      font-family: sans-serif;
      display: flex; 
      flex-direction: column; 
      align-items: center;
    }
    h1 {
      margin: 1rem 0 0.5rem;
    }
    /* Container for the canvas and overlays */
    #gameContainer {
      position: relative;
      width: 720px;    /* same as canvas' internal width */
      max-width: 100%; /* allow shrinking on small screens */
    }
    canvas {
      display: block;
      background: #fff;
      width: 100%;      /* scale to container */
      height: auto;     /* keep aspect ratio */
    }

    /* Overlays for each game state: menu, instructions, color_choice, etc. */
    .overlayScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;   /* shown/hidden dynamically */
      background: rgba(255,255,255,0.95);
      align-items: center; 
      justify-content: flex-start;
      flex-direction: column;
      padding-top: 80px;
      text-align: center;
    }
    button {
      font-size: 18px; margin: 10px; padding: 10px 20px; cursor: pointer;
    }
  </style>
</head>
<body>

<h1>Another Product Invented Chess</h1>

<div id="gameContainer">
  <!-- The game canvas. Same width/height as your Python version. -->
  <canvas id="chessCanvas" width="720" height="800"></canvas>

  <!-- MENU -->
  <div id="menuScreen" class="overlayScreen">
    <h2>Another Product Invented Chess</h2>
    <button id="newGameBtn">New Game</button>
    <button id="instructionsBtn">Instructions</button>
  </div>

  <!-- INSTRUCTIONS -->
  <div id="instructionsScreen" class="overlayScreen">
    <p><strong>Objective</strong></p>
    <p>The goal is to checkmate your opponent's king.</p>
    <p>Checkmate happens when the king is under attack and cannot escape.</p>
    <br/>
    <p><strong>How the Pieces Move</strong></p>
    <p>Pawn: Moves forward one or two squares initially, captures diagonally, promotes on last rank.</p>
    <p>Rook: Moves horizontally or vertically any distance.</p>
    <p>Knight: Moves in an L-shape. Jumps over pieces.</p>
    <p>Bishop: Moves diagonally any distance.</p>
    <p>Queen: Moves any distance in any direction.</p>
    <p>King: Moves 1 square in any direction, but cannot move into check.</p>
    <br/>
    <p>Press [M] to return to the Main Menu.</p>
  </div>

  <!-- COLOR CHOICE -->
  <div id="colorScreen" class="overlayScreen">
    <p>Choose Your Side:</p>
    <button id="whiteSideBtn">White [W]</button>
    <button id="blackSideBtn">Black [B]</button>
  </div>

  <!-- DIFFICULTY CHOICE -->
  <div id="difficultyScreen" class="overlayScreen">
    <p>Select Difficulty:</p>
    <button id="easyBtn">Easy [E]</button>
    <button id="mediumBtn">Medium [M]</button>
    <button id="hardBtn">Hard [H]</button>
  </div>

  <!-- GAME OVER -->
  <div id="gameOverScreen" class="overlayScreen">
    <h2 id="gameOverText"></h2>
    <p>Press [M] to return to the Main Menu.</p>
  </div>
</div>

<!-- chess.js for chess logic (alpha/beta won't matter, just needed for rules). -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.min.js"></script>
<script>
var Chess = window.Chess || new Chess();

const canvas = document.getElementById("chessCanvas");
const ctx = canvas.getContext("2d");

// Overlays
const menuScreen = document.getElementById("menuScreen");
const instructionsScreen = document.getElementById("instructionsScreen");
const colorScreen = document.getElementById("colorScreen");
const difficultyScreen = document.getElementById("difficultyScreen");
const gameOverScreen = document.getElementById("gameOverScreen");
const gameOverText = document.getElementById("gameOverText");

// Constants
const WIDTH=720, HEIGHT=800;
const SQUARE_SIZE=90;
const PIECE_SIZE=88; 
// Colors
const TAN = "rgb(227,193,111)";
const BROWN= "rgb(184,139,74)";
const YELLOW= "rgba(255,255,0,0.47)";
const PINK  = "rgba(255,192,203,1)";
const ORANGE= "rgba(255,165,0,1)";
const WHITE= "#fff";
const BLACK= "#000";

// Game states
let gameState="menu"; 
let running=true;

// Chess logic
const chess = new Chess();

// Selections
let selectedSquare=null;
let legalMoves=[];
let lastMove=null;
let playerColor=null;  // 'w' or 'b'
let difficulty=null;   // "easy","medium","hard"

// AI & Minimax config
const PIECE_VALUES={
  p:1, n:3, b:3, r:5, q:9, k:0
};

// We'll store images in "pieces" dict
const pieces={};
const pieceNames=["king","queen","rook","bishop","knight","pawn"];
const pieceColors=["white","black"];

// Load images
function loadImages(callback) {
  let total= pieceNames.length*pieceColors.length;
  let loaded=0;
  pieceColors.forEach(col=>{
    pieceNames.forEach(nm=>{
      let key=`${col}_${nm}`;
      let img=new Image();
      img.src=`pieces/${col}_${nm}.png`;
      img.onload=()=>{
        pieces[key]=img;
        loaded++;
        if (loaded===total) callback();
      };
    });
  });
}

////////////////////////////////////////////////////////////////////////////////
// Minimax with alpha-beta & time-limits
////////////////////////////////////////////////////////////////////////////////
function evaluateBoard(chInst) {
  // If game over, check outcome
  if (chInst.isGameOver()) {
    if (chInst.inDraw() || chInst.inStalemate()) {
      return 0; // draw
    }
    // if checkmate => side to move lost => big Â±
    return (chInst.turn()==='w')? -9999 : 9999;
  }
  // material count
  let boardArr= chInst.board();
  let score=0;
  for (let row=0; row<8; row++){
    for (let col=0; col<8; col++){
      let piece= boardArr[row][col];
      if (piece) {
        let val= PIECE_VALUES[piece.type];
        if (piece.color==='w') score+=val; else score-=val;
      }
    }
  }
  return score;
}

function minimax(chInst, depth, alpha, beta, maximizing, endTime){
  if (depth===0 || chInst.isGameOver() || Date.now()>endTime) {
    return evaluateBoard(chInst);
  }
  let moves= chInst.moves({verbose:true});
  if (maximizing){
    let value=-999999;
    for (let mv of moves){
      chInst.move(mv);
      value=Math.max(value, minimax(chInst, depth-1, alpha,beta,false,endTime));
      chInst.undo();
      alpha=Math.max(alpha,value);
      if (beta<=alpha) break;
      if (Date.now()>endTime) break;
    }
    return value;
  } else {
    let value=999999;
    for (let mv of moves){
      chInst.move(mv);
      value=Math.min(value, minimax(chInst, depth-1, alpha,beta,true,endTime));
      chInst.undo();
      beta=Math.min(beta,value);
      if (beta<=alpha) break;
      if (Date.now()>endTime) break;
    }
    return value;
  }
}

function findBestMove(chInst, depth, maxTime){
  let bestMove=null;
  let bestValue=-999999;
  let endTime= Date.now()+maxTime;
  let moves= chInst.moves({verbose:true});
  // shuffle
  for (let i=moves.length-1; i>0; i--){
    let rIdx=Math.floor(Math.random()*(i+1));
    [moves[i],moves[rIdx]]=[moves[rIdx],moves[i]];
  }
  for (let mv of moves){
    if (Date.now()>endTime) break;
    chInst.move(mv);
    let val= minimax(chInst, depth-1, -100000,100000,false,endTime);
    chInst.undo();
    if (val>bestValue){
      bestValue=val;
      bestMove=mv;
    }
  }
  if (!bestMove && moves.length>0){
    return moves[Math.floor(Math.random()*moves.length)];
  }
  return bestMove;
}

function getAiMove(difficultyStr, chInst){
  let moves= chInst.moves({verbose:true});
  if (!moves.length) return null;
  if (difficultyStr==="easy") {
    return moves[Math.floor(Math.random()*moves.length)];
  } else if (difficultyStr==="medium"){
    // depth=2,4s
    return findBestMove(chInst,2,4000) || moves[0];
  } else if (difficultyStr==="hard"){
    // depth=4,8s
    return findBestMove(chInst,4,8000) || moves[0];
  } else {
    return moves[Math.floor(Math.random()*moves.length)];
  }
}

////////////////////////////////////////////////////////////////////////////////
// Board <-> Screen
////////////////////////////////////////////////////////////////////////////////
function boardToScreen(row,col){
  // if player_color == chess.WHITE => 7-row
  if (playerColor==='w') return {sr:7-row, sc:7-col};
  return {sr:row, sc:col};
}
function screenToBoard(sr,sc){
  if (playerColor==='w') return {r:7-sr, c:7-sc};
  return {r:sr, c:sc};
}

// If we want to convert python-chess squares => algebraic, we do that in logic

////////////////////////////////////////////////////////////////////////////////
// Drawing 
////////////////////////////////////////////////////////////////////////////////
function drawBoardOnly() {
  for (let row=0; row<8; row++){
    for (let col=0; col<8; col++){
      let {sr, sc}= boardToScreen(row,col);
      let color=((row+col)%2===0)? TAN:BROWN;
      ctx.fillStyle=color;
      ctx.fillRect(sc*SQUARE_SIZE, sr*SQUARE_SIZE, SQUARE_SIZE,SQUARE_SIZE);
    }
  }
}
function drawLastMove(){
  if (!lastMove) return;
  // lastMove e.g. {from:'e2', to:'e4'}
  let fromRC= algToRC(lastMove.from); // {row,col}
  let toRC= algToRC(lastMove.to);
  let {sr:fsr,sc:fsc}= boardToScreen(fromRC.row,fromRC.col);
  let {sr:tsr,sc:tsc}= boardToScreen(toRC.row,toRC.col);
  // pink, orange
  ctx.fillStyle=PINK;
  ctx.fillRect(fsc*SQUARE_SIZE, fsr*SQUARE_SIZE, SQUARE_SIZE,SQUARE_SIZE);
  ctx.fillStyle=ORANGE;
  ctx.fillRect(tsc*SQUARE_SIZE, tsr*SQUARE_SIZE, SQUARE_SIZE,SQUARE_SIZE);
}
function drawHighlights(){
  if (!selectedSquare) return;
  ctx.fillStyle=YELLOW;
  for (let mv of legalMoves){
    let toRC= algToRC(mv.to);
    let {sr,sc}= boardToScreen(toRC.row,toRC.col);
    ctx.fillRect(sc*SQUARE_SIZE, sr*SQUARE_SIZE, SQUARE_SIZE,SQUARE_SIZE);
  }
}
function drawPiecesOnTop(){
  // read the chess.js board
  let symbolMap={p:"pawn", n:"knight", b:"bishop", r:"rook", q:"queen", k:"king"};
  let bArr= chess.board();
  for (let row=0; row<8; row++){
    for (let col=0; col<8; col++){
      let piece= bArr[row][col];
      if (!piece) continue;
      let colorStr= (piece.color==='w')?"white":"black";
      let pieceStr= symbolMap[piece.type];
      let key=`${colorStr}_${pieceStr}`;
      let {sr,sc}= boardToScreen(row,col);
      ctx.drawImage(pieces[key], sc*SQUARE_SIZE, sr*SQUARE_SIZE, PIECE_SIZE, PIECE_SIZE);
    }
  }
}
function drawBottomBar(text=""){
  let barHeight=60;
  ctx.fillStyle=WHITE;
  ctx.fillRect(0, HEIGHT-barHeight, WIDTH, barHeight);
  ctx.fillStyle=BLACK;
  ctx.font="24px sans-serif";
  ctx.fillText(text, 10, HEIGHT-20);
}

function redrawPlayScreen(){
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  drawBoardOnly();
  drawLastMove();
  drawHighlights();
  drawPiecesOnTop();
  drawBottomBar("Click piece, then square. Press [M] for menu.");
}

function algToRC(alg) {
  // 'a' => file=0, 'h'=> file=7
  let file=alg.charCodeAt(0)-'a'.charCodeAt(0);
  let rank= parseInt(alg[1]);
  let row= 8-rank;
  let col= file;
  return {row,col};
}

////////////////////////////////////////////////////////////////////////////////
// State Handlers (like in your Python code)
////////////////////////////////////////////////////////////////////////////////
// We'll have handle_menu(), handle_instructions(), handle_color_choice(),
// handle_difficulty_choice(), handle_playing(), handle_game_over().

const menuScreenDiv = document.getElementById("menuScreen");
const instructionsScreenDiv = document.getElementById("instructionsScreen");
const colorScreenDiv = document.getElementById("colorScreen");
const difficultyScreenDiv = document.getElementById("difficultyScreen");
const gameOverScreenDiv = document.getElementById("gameOverScreen");
const gameOverTextDiv = document.getElementById("gameOverText");

function hideAllScreens(){
  menuScreenDiv.style.display="none";
  instructionsScreenDiv.style.display="none";
  colorScreenDiv.style.display="none";
  difficultyScreenDiv.style.display="none";
  gameOverScreenDiv.style.display="none";
}

function handle_menu(){
  hideAllScreens();
  menuScreenDiv.style.display="flex";
}

function handle_instructions(){
  hideAllScreens();
  instructionsScreenDiv.style.display="flex";
}

function handle_color_choice(){
  hideAllScreens();
  colorScreenDiv.style.display="flex";
}

function handle_difficulty_choice(){
  hideAllScreens();
  difficultyScreenDiv.style.display="flex";
}

function handle_playing(){
  hideAllScreens();
  document.getElementById("chessCanvas").style.display = "block"; // Ensure board is visible
  requestAnimationFrame(mainLoop); // Start the game loop
}

function handle_game_over(){
  hideAllScreens();
  gameOverScreenDiv.style.display="flex";
}

////////////////////////////////////////////////////////////////////////////////
// The main loop
////////////////////////////////////////////////////////////////////////////////
function mainLoop(){
  // We'll replicate your "if game_state == ..." approach
  switch(gameState){
    case "menu": 
      handle_menu(); 
      break;
    case "instructions":
      handle_instructions();
      break;
    case "color_choice":
      handle_color_choice();
      break;
    case "difficulty_choice":
      handle_difficulty_choice();
      break;
    case "playing":
      handle_playing();
      break;
    case "game_over":
      handle_game_over();
      break;
  }
  requestAnimationFrame(mainLoop);
}

////////////////////////////////////////////////////////////////////////////////
// Input: Canvas clicks => selecting squares
////////////////////////////////////////////////////////////////////////////////
canvas.addEventListener("mousedown",(e)=>{
  if (gameState!=="playing") return;
  let rect=canvas.getBoundingClientRect();
  let mx=e.clientX-rect.left, my=e.clientY-rect.top;
  if (my>=SQUARE_SIZE*8) return; // clicked bottom bar or beyond board

  let scrCol=Math.floor(mx/SQUARE_SIZE);
  let scrRow=Math.floor(my/SQUARE_SIZE);
  let {r,c}= screenToBoard(scrRow,scrCol);
  // Convert r,c => algebraic 
  let file= String.fromCharCode('a'.charCodeAt(0)+c);
  let rank= (8-r).toString();
  let square= file+rank; // e.g. 'e2'

  if (!selectedSquare){
    let piece= chess.get(square);
    if (piece && piece.color===chess.turn()){
      selectedSquare=square;
      let all=chess.moves({verbose:true});
      legalMoves= all.filter(m=> m.from===square);
    }
  } else {
    let candidate= legalMoves.find(m=> m.to===square);
    if (candidate){
      chess.move(candidate);
      lastMove=candidate;
      selectedSquare=null;
      legalMoves=[];
      // Check game over
      if (chess.isGameOver()){
        gameState="game_over";
        let outcomeText="Game Over: ";
        if (chess.inCheckmate()){
          // side to move lost
          if (chess.turn()==='w') outcomeText+="Black Wins!";
          else outcomeText+="White Wins!";
        } else {
          outcomeText+="It's a Draw!";
        }
        gameOverTextDiv.textContent= outcomeText;
      } else {
        // AI turn if needed
        setTimeout(aiTurnIfNeeded, 300);
      }
    } else {
      // invalid
      selectedSquare=null; 
      legalMoves=[];
    }
  }
});

function aiTurnIfNeeded(){
  // If user is white and it's black's turn => AI 
  // or user is black and it's white's turn => AI
  if ((playerColor==='w' && chess.turn()==='b')||
      (playerColor==='b' && chess.turn()==='w')){
    if (difficulty==="medium"||difficulty==="hard"){
      // show "Thinking..."
      ctx.fillStyle="rgba(255,255,255,0.9)";
      ctx.fillRect(WIDTH/2-100, HEIGHT/2-30, 200,60);
      ctx.fillStyle="#000";
      ctx.font="24px sans-serif";
      ctx.fillText("Thinking...", WIDTH/2-50, HEIGHT/2);
    }
    let mv=getAiMove(difficulty, chess);
    if (mv){
      chess.move(mv);
      lastMove=mv;
    }
    if (chess.isGameOver()){
      gameState="game_over";
      let outcomeText="Game Over: ";
      if (chess.inCheckmate()){
        if (chess.turn()==='w') outcomeText+="Black Wins!";
        else outcomeText+="White Wins!";
      } else {
        outcomeText+="It's a Draw!";
      }
      gameOverTextDiv.textContent= outcomeText;
    }
  }
}

////////////////////////////////////////////////////////////////////////////////
// Buttons & Keyboard
////////////////////////////////////////////////////////////////////////////////
document.getElementById("newGameBtn").onclick=()=>{
  gameState="color_choice";
  hideAllScreens();
  colorScreenDiv.style.display = "flex"; // Show the color selection screen
};
document.getElementById("instructionsBtn").onclick=()=>{
  gameState="instructions";
};

document.getElementById("whiteSideBtn").onclick=()=>{
  playerColor='w';
  chess.reset();
  selectedSquare=null; legalMoves=[]; lastMove=null;
  gameState="difficulty_choice";
};
document.getElementById("blackSideBtn").onclick=()=>{
  playerColor='b';
  chess.reset();
  selectedSquare=null; legalMoves=[]; lastMove=null;
  gameState="difficulty_choice";
};

document.getElementById("easyBtn").onclick=()=>{
  difficulty="easy";
  chess.reset();
  selectedSquare=null; legalMoves=[]; lastMove=null;
  gameState="playing";
};
document.getElementById("mediumBtn").onclick=()=>{
  difficulty="medium";
  chess.reset();
  selectedSquare=null; legalMoves=[]; lastMove=null;
  gameState="playing";
};
document.getElementById("hardBtn").onclick=()=>{
  difficulty="hard";
  chess.reset();
  selectedSquare=null; legalMoves=[]; lastMove=null;
  gameState="playing";
};

// Press M => back to menu
document.addEventListener("keydown",(e)=>{
  if (e.key.toLowerCase()==='m'){
    if (["playing","instructions","game_over"].includes(gameState)){
      chess.reset();
      selectedSquare=null; legalMoves=[]; lastMove=null;
      gameState="menu";
    }
  }
});

////////////////////////////////////////////////////////////////////////////////
// Start
////////////////////////////////////////////////////////////////////////////////
function startAll(){
  chess.reset(); 
  hideAllScreens(); // Hide everything first
  menuScreenDiv.style.display = "flex"; // Show the menu
  loadImages(()=>{
    requestAnimationFrame(mainLoop);
  });
  window.onload = startAll;
</script>
</body>
</html>


