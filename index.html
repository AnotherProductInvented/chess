<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Another Product Invented Chess</title>
  <style>
    body {
      margin: 0; padding: 0; 
      background: #fff; 
      font-family: sans-serif;
      display: flex; 
      flex-direction: column; 
      align-items: center;
    }
    h1 {
      margin: 1rem 0 0.5rem;
    }
    #gameContainer {
      position: relative;
      width: 720px;   /* same as canvas internal width */
      max-width: 100%;
    }

   

    canvas {
      display: block;
      background: #fff;
      width: 100%;
      height: auto;
    }
    .overlayScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;  /* shown/hidden dynamically */
      background: rgba(255,255,255,0.95);
      align-items: center; 
      justify-content: flex-start;
      flex-direction: column;
      padding-top: 80px;
      text-align: center;
    }
    button {
      font-size: 18px; margin: 10px; padding: 10px 20px; cursor: pointer;
    }
  </style>
</head>
<body>

<h1>Another Product Invented Chess</h1>

<div id="gameContainer">
<!-- MENU SCREEN -->
<div id="menuScreen" class="overlayScreen">
  <h2>Another Product Invented Chess</h2>
  <button id="newGameBtn">New Game</button>
  <button id="instructionsBtn">Instructions</button>
</div>


  <canvas id="chessCanvas" width="720" height="800"></canvas>


  <!-- INSTRUCTIONS -->
  <div id="instructionsScreen" class="overlayScreen">
    <p><strong>Objective</strong></p>
    <p>The goal is to checkmate your opponent's king.</p>
    <p>Checkmate happens when the king is under attack and cannot escape.</p>
    <br/>
    <p><strong>How the Pieces Move</strong></p>
    <p>Pawn: Moves forward one or two squares initially, captures diagonally, promotes on last rank.</p>
    <p>Rook: Moves horizontally or vertically any distance.</p>
    <p>Knight: Moves in an L-shape. Jumps over pieces.</p>
    <p>Bishop: Moves diagonally any distance.</p>
    <p>Queen: Moves any distance in any direction.</p>
    <p>King: Moves 1 square in any direction, but cannot move into check.</p>
    <br/>
    <p>Press [M] to return to the Main Menu.</p>
  </div>

  <!-- COLOR CHOICE -->
  <div id="colorScreen" class="overlayScreen">
    <p>Choose Your Side:</p>
    <button id="whiteSideBtn">White [W]</button>
    <button id="blackSideBtn">Black [B]</button>
  </div>

  <!-- DIFFICULTY -->
  <div id="difficultyScreen" class="overlayScreen">
    <p>Select Difficulty:</p>
    <button id="easyBtn">Easy [E]</button>
    <button id="mediumBtn">Medium [M]</button>
    <button id="hardBtn">Hard [H]</button>
  </div>

  <!-- GAME OVER -->
  <div id="gameOverScreen" class="overlayScreen">
    <h2 id="gameOverText"></h2>
    <p>Press [M] to return to the Main Menu.</p>
  </div>
</div>

<!-- chess.js for logic -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/1.0.0/chess.js"></script>
<script>
////////////////////////////////////////////////////////////////////////////////
// Global & Constants
////////////////////////////////////////////////////////////////////////////////
const canvas = document.getElementById("chessCanvas");
const menuScreen = document.getElementById("menuScreen");
const ctx = canvas.getContext("2d");

// Overlays

const instructionsScreen = document.getElementById("instructionsScreen");
const colorScreen = document.getElementById("colorScreen");
const difficultyScreen = document.getElementById("difficultyScreen");
const gameOverScreen = document.getElementById("gameOverScreen");
const gameOverText = document.getElementById("gameOverText");

const WIDTH=720, HEIGHT=800;
const SQUARE_SIZE=90;
const PIECE_SIZE=88; 

// Colors
const TAN = "rgb(227,193,111)";
const BROWN= "rgb(184,139,74)";
const YELLOW= "rgba(255,255,0,0.47)";
const PINK  = "rgba(255,192,203,1)";
const ORANGE= "rgba(255,165,0,1)";
const WHITE= "#fff";
const BLACK= "#000";

let gameState = "menu";
console.log("GameState is now:", gameState);
function handle_menu(){
  console.log("GameState is now:", gameState);
  hideAllScreens();
  menuScreen.style.display="flex";
}

let running = true;

// chess.js instance
const chess = new Chess(); // Ensure chess.js is properly loaded
console.log("Chess.js initialized:", chess);

// Selections
let selectedSquare = null;
let legalMoves = [];
let lastMove = null;
let playerColor = null; // 'w','b'
let difficulty = null;  // 'easy','medium','hard'

////////////////////////////////////////////////////////////////////////////////
// Minimimax
////////////////////////////////////////////////////////////////////////////////
const PIECE_VALUES = {p:1,n:3,b:3,r:5,q:9,k:0};

function evaluateBoard(chInst){
  if (chInst.isGameOver()){
    if (chInst.inDraw()||chInst.inStalemate()) return 0;
    return (chInst.turn()==='w')? -9999 : 9999;
  }
  let score=0;
  let brd= chInst.board();
  for (let row=0; row<8; row++){
    for (let col=0; col<8; col++){
      let p= brd[row][col];
      if (p){
        let val= PIECE_VALUES[p.type];
        if (p.color==='w') score+=val; else score-=val;
      }
    }
  }
  return score;
}
function minimax(chInst, depth, alpha,beta, maximizing, endTime){
  if (depth===0 || chInst.isGameOver() || Date.now()>endTime){
    return evaluateBoard(chInst);
  }
  let moves= chInst.moves({verbose:true});
  if (maximizing){
    let value=-999999;
    for (let mv of moves){
      chInst.move(mv);
      value= Math.max(value, minimax(chInst, depth-1, alpha,beta,false,endTime));
      chInst.undo();
      alpha= Math.max(alpha,value);
      if (beta<=alpha) break;
      if (Date.now()>endTime) break;
    }
    return value;
  } else {
    let value=999999;
    for (let mv of moves){
      chInst.move(mv);
      value= Math.min(value, minimax(chInst, depth-1, alpha,beta,true,endTime));
      chInst.undo();
      beta= Math.min(beta,value);
      if (beta<=alpha) break;
      if (Date.now()>endTime) break;
    }
    return value;
  }
}

function findBestMove(chInst, depth, maxTime) {
  let bestMove = null;
  let bestValue = -999999;
  let endTime = Date.now() + maxTime;
  let moves = chInst.moves({ verbose: true });

  // Shuffle moves for randomness
  for (let i = moves.length - 1; i > 0; i--) {
    let ridx = Math.floor(Math.random() * (i + 1));
    [moves[i], moves[ridx]] = [moves[ridx], moves[i]];
  }

  for (let mv of moves) {
    if (Date.now() > endTime) break; // Stop if time runs out
    chInst.move(mv);
    let val = minimax(chInst, depth - 1, -100000, 100000, false, endTime);
    chInst.undo();

    if (val > bestValue) {
      bestValue = val;
      bestMove = mv;
    }
  }

  // Ensure a valid move is returned
  if (!bestMove && moves.length > 0) {
    return moves[Math.floor(Math.random() * moves.length)];
  }
  return bestMove;
}


function getAiMove(diffStr, chInst){
  let moves= chInst.moves({verbose:true});
  if (!moves.length) return null;
  if (diffStr==="easy"){
    return moves[Math.floor(Math.random()*moves.length)];
  } else if (diffStr==="medium"){
    return findBestMove(chInst,2,4000) || moves[0];
  } else if (diffStr==="hard"){
    return findBestMove(chInst,4,8000) || moves[0];
  } else {
    return moves[Math.floor(Math.random()*moves.length)];
  }
}

////////////////////////////////////////////////////////////////////////////////
// Drawing
////////////////////////////////////////////////////////////////////////////////
function boardToScreen(row,col){
  if (playerColor==='w') return {sr:7-row, sc:7-col};
  return {sr:row, sc:col};
}
function screenToBoard(sr,sc){
  if (playerColor==='w') return {r:7-sr, c:7-sc};
  return {r:sr, c:sc};
}
function algToRC(a){
  let file= a.charCodeAt(0)-'a'.charCodeAt(0); //0..7
  let rank= parseInt(a[1]); //1..8
  let row=8-rank; 
  let col=file;
  return {row,col};
}

function drawBoardOnly(){
  for (let row=0; row<8; row++){
    for (let col=0; col<8; col++){
      let {sr,sc}= boardToScreen(row,col);
      let color=((row+col)%2===0)? TAN: BROWN;
      ctx.fillStyle=color;
      ctx.fillRect(sc*SQUARE_SIZE, sr*SQUARE_SIZE, SQUARE_SIZE,SQUARE_SIZE);
    }
  }
}
function drawLastMove(){
  if (!lastMove) return;
  let {from,to}= lastMove;
  let frc= algToRC(from);
  let toc= algToRC(to);
  let {sr:fsr,sc:fsc}= boardToScreen(frc.row,frc.col);
  let {sr:tsr,sc:tsc}= boardToScreen(toc.row,toc.col);
  // fill pink, orange
  ctx.fillStyle=PINK;
  ctx.fillRect(fsc*SQUARE_SIZE, fsr*SQUARE_SIZE, SQUARE_SIZE,SQUARE_SIZE);
  ctx.fillStyle=ORANGE;
  ctx.fillRect(tsc*SQUARE_SIZE, tsr*SQUARE_SIZE, SQUARE_SIZE,SQUARE_SIZE);
}
function drawHighlights(){
  if (!selectedSquare) return;
  ctx.fillStyle = "rgba(255, 255, 0, 0.5)";
  for (let mv of legalMoves){
    let toRC = algToRC(mv.to);
    let { sr, sc } = boardToScreen(toRC.row, toRC.col);
    ctx.beginPath();
    ctx.arc(sc * SQUARE_SIZE + SQUARE_SIZE / 2, sr * SQUARE_SIZE + SQUARE_SIZE / 2, SQUARE_SIZE / 4, 0, Math.PI * 2);
    ctx.fill();
  }
}

const pieceMap= { p:"pawn", n:"knight", b:"bishop", r:"rook", q:"queen", k:"king" };
const loadedPieces={}; // loaded images => e.g. "white_pawn" => Image
function drawPiecesOnTop() {
  let brd = chess.board();
  for (let row = 0; row < 8; row++){
    for (let col = 0; col < 8; col++){
      let piece = brd[row][col];
      if (!piece) continue;

      let colorStr = (piece.color === 'w') ? "white" : "black";
      let pName = pieceMap[piece.type];
      let key = `${colorStr}_${pName}`;

      if (pieces[key]) {
        let { sr, sc } = boardToScreen(row, col);
        ctx.drawImage(pieces[key], sc * SQUARE_SIZE, sr * SQUARE_SIZE, PIECE_SIZE, PIECE_SIZE);
      } else {
        console.warn(`Missing image: ${key}`);
      }
    }

  for (let row=0; row<8; row++){
    for (let col=0; col<8; col++){
      let piece = brd[row][col];
      if (!piece) continue;  // ✅ Fix: Skip if no piece is there

      let colorStr = (piece.color === 'w') ? "white" : "black";
      let pName = pieceMap[piece.type];
      let key = `${colorStr}_${pName}`;

      // Ensure image exists before drawing
      if (pieces[key]) {
        let { sr, sc } = boardToScreen(row, col);
        ctx.drawImage(pieces[key], sc * SQUARE_SIZE, sr * SQUARE_SIZE, PIECE_SIZE, PIECE_SIZE);
      }
    }
  }
}

  for (let row=0; row<8; row++){
    for (let col=0; col<8; col++){
      let piece= brd[row][col];
      if (!piece) continue;
      let colorStr=(piece.color==='w')? "white":"black";
      let pName= pieceMap[piece.type];
      let key= `${colorStr}_${pName}`;
      let {sr,sc}= boardToScreen(row,col);
      ctx.drawImage(pieces[key], sc*SQUARE_SIZE, sr*SQUARE_SIZE, PIECE_SIZE,PIECE_SIZE);
    }
}
function drawBottomBar(txt=""){
  let barHeight=60;
  ctx.fillStyle=WHITE;
  ctx.fillRect(0,HEIGHT-barHeight, WIDTH, barHeight);
  ctx.fillStyle=BLACK;
  ctx.font="24px sans-serif";
  ctx.fillText(txt, 10, HEIGHT-20);
}

function redrawPlayScreen(){
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  drawBoardOnly();
  drawLastMove();
  drawHighlights();
  drawPiecesOnTop();
  drawBottomBar("Click piece, then square. Press [M] for menu.");
}

////////////////////////////////////////////////////////////////////////////////
// Overlays
////////////////////////////////////////////////////////////////////////////////
function hideAllScreens(){
  menuScreen.style.display="none";
  instructionsScreen.style.display="none";
  colorScreen.style.display="none";
  difficultyScreen.style.display="none";
  gameOverScreen.style.display="none";
}
function handle_menu(){ hideAllScreens(); menuScreen.style.display="flex"; }
function handle_instructions(){ hideAllScreens(); instructionsScreen.style.display="flex"; }
function handle_color_choice(){ hideAllScreens(); colorScreen.style.display="flex"; }
function handle_difficulty_choice(){ hideAllScreens(); difficultyScreen.style.display="flex"; }
function handle_playing(){
  hideAllScreens();
  // Show the canvas by default (it's always visible)
  redrawPlayScreen();
}
function handle_game_over(){ hideAllScreens(); gameOverScreen.style.display="flex"; }

////////////////////////////////////////////////////////////////////////////////
// The mainLoop (like your Python "while running" with states)
////////////////////////////////////////////////////////////////////////////////
function mainLoop(){
  switch(gameState){
    case "menu": 
      handle_menu();
      break;
    case "instructions":
      handle_instructions();
      break;
    case "color_choice":
      handle_color_choice();
      break;
    case "difficulty_choice":
      handle_difficulty_choice();
      break;
    case "playing":
      // If we are in playing, we keep drawing the board each frame
      handle_playing();
      break;
    case "game_over":
      handle_game_over();
      break;
  }
  requestAnimationFrame(mainLoop);
}

////////////////////////////////////////////////////////////////////////////////
// Mouse: Canvas clicks
////////////////////////////////////////////////////////////////////////////////
canvas.addEventListener("mousedown",(e)=>{
  if (gameState!=="playing") return;
  let rect=canvas.getBoundingClientRect();
  let mx=e.clientX-rect.left, my=e.clientY-rect.top;
  if (my>=8*SQUARE_SIZE) return; // bottom bar or outside board

  let scrCol=Math.floor(mx/SQUARE_SIZE);
  let scrRow=Math.floor(my/SQUARE_SIZE);
  let {r,c}= screenToBoard(scrRow,scrCol);
  let file= String.fromCharCode('a'.charCodeAt(0)+c);
  let rank=(8-r).toString();
  let square= file+rank; 

  if (!selectedSquare){
    let piece= chess.get(square);
    if (piece && piece.color===chess.turn()){
      selectedSquare=square;
      let all= chess.moves({verbose:true});
      legalMoves= all.filter(m=> m.from===square);
    }
  } else {
    let candidate= legalMoves.find(m=>m.to===square);
    if (candidate){
      chess.move(candidate);
      lastMove=candidate;
      selectedSquare=null;
      legalMoves=[];
      // check game over
      if (chess.isGameOver()){
        gameState="game_over";
        let result="Game Over: ";
        if (chess.inCheckmate()){
          if (chess.turn()==='w') result+="Black Wins!";
          else result+="White Wins!";
        } else {
          result+="It's a Draw!";
        }
        gameOverText.textContent= result;
      } else {
        // AI turn?
  if (!chess.isGameOver()) aiTurnIfNeeded();
}, 100);

      }
    } else {
      selectedSquare=null;
      legalMoves=[];
    }
  }
});

function aiTurnIfNeeded(){
  if ((playerColor==='w' && chess.turn()==='b')||
      (playerColor==='b' && chess.turn()==='w')){
    // do AI
    if (difficulty==="medium"||difficulty==="hard"){
      // show "Thinking..."
      ctx.fillStyle="rgba(255,255,255,0.9)";
      ctx.fillRect(WIDTH/2-100, HEIGHT/2-30, 200,60);
      ctx.fillStyle="#000";
      ctx.font="24px sans-serif";
      ctx.fillText("Thinking...", WIDTH/2-50, HEIGHT/2);
    }
    let mv=getAiMove(difficulty, chess);
    if (mv) {
  chess.move(mv);
  lastMove = mv;
  if (chess.isGameOver()) {
    gameState = "game_over";
    let result = "Game Over: ";
    if (chess.inCheckmate()) {
      result += (chess.turn() === 'w') ? "Black Wins!" : "White Wins!";
    } else {
      result += "It's a Draw!";
    }
    gameOverText.textContent = result;
  }
} else {
  console.log("No valid move available. It's a draw.");
}

}

////////////////////////////////////////////////////////////////////////////////
// Buttons & Keys
////////////////////////////////////////////////////////////////////////////////
const newGameBtn = document.getElementById("newGameBtn");
if (newGameBtn) {
  newGameBtn.onclick = () => {
    gameState = "color_choice";
    console.log("GameState is now:", gameState);
  };
} else {
  console.error("Error: newGameBtn not found!");
}
const instructionsBtn = document.getElementById("instructionsBtn");
if (instructionsBtn) {
  instructionsBtn.onclick = () => {
    gameState = "instructions";
    console.log("GameState is now:", gameState);
    handle_instructions();
  };
} else {
  console.error("Error: instructionsBtn not found!");
}



document.getElementById("whiteSideBtn").onclick=()=>{
  playerColor='w';
  chess.reset();
  selectedSquare=null; legalMoves=[]; lastMove=null;
  gameState="difficulty_choice";
};
document.getElementById("blackSideBtn").onclick=()=>{
  playerColor='b';
  chess.reset();
  selectedSquare=null; legalMoves=[]; lastMove=null;
  gameState="difficulty_choice";
};

document.getElementById("easyBtn").onclick=()=>{
  difficulty="easy";
  chess.reset();
  selectedSquare=null; legalMoves=[]; lastMove=null;
  gameState="playing";
};
document.getElementById("mediumBtn").onclick=()=>{
  difficulty="medium";
  chess.reset();
  selectedSquare=null; legalMoves=[]; lastMove=null;
  gameState="playing";
};
document.getElementById("hardBtn").onclick=()=>{
  difficulty="hard";
  chess.reset();
  selectedSquare=null; legalMoves=[]; lastMove=null;
  gameState="playing";
};

// Press [M] => go to menu
document.addEventListener("keydown",(e)=>{
  if (e.key.toLowerCase()==='m'){
    if (["playing","instructions","game_over"].includes(gameState)){
      chess.reset();
      selectedSquare=null; legalMoves=[]; lastMove=null;
      gameState="menu";
    }
  }
});
const pieces = {};  // ✅ Fix: Define an empty object to store images
function loadImages(callback) {
  // List all piece names
  const pieceNames = ["king","queen","rook","bishop","knight","pawn"];
  const pieceColors = ["white","black"];

  let total = pieceNames.length * pieceColors.length;
  let loaded = 0;

  pieceColors.forEach(color => {
    pieceNames.forEach(name => {
      const key = `${color}_${name}`;
      const img = new Image();
      // The path "pieces/white_king.png", etc.
      img.src = `pieces/${color}_${name}.png`;
      img.onload = () => {
        // Store in your `pieces` object:
        pieces[key] = img;
        loaded++;
        // Once all are loaded, call callback()
        if (loaded === total) {
          callback();
        }
      };
    });
  });
}




////////////////////////////////////////////////////////////////////////////////
// Start
////////////////////////////////////////////////////////////////////////////////
function startAll(){
  console.log("starting everything...");
  chess.reset();
  console.log("Testing chess.board():", typeof chess.board);
  hideAllScreens();
  menuScreen.style.display="flex";

  loadImages(()=>{
    console.log("Images loaded.");
    requestAnimationFrame(mainLoop);
  });
}

window.addEventListener("load",()=> startAll());
</script>
</body>
</html>
