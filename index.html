////////////////////////////////////////////////////////////////////////////////
// Python-like variables
////////////////////////////////////////////////////////////////////////////////
const WIDTH = 720, HEIGHT = 800;
const SQUARE_SIZE = 90;
const PIECE_SIZE = 88;  // Not truly used unless we want smaller pieces

const COLORS = {
  WHITE: "#FFFFFF",
  BROWN: "rgb(184,139,74)",
  TAN:   "rgb(227,193,111)",
  BLACK: "#000000",
  YELLOW: "rgba(255,255,0,0.47)",
  FROM_SQ: "rgba(255,192,203,0.9)", // Pink
  TO_SQ:   "rgba(255,165,0,0.9)"    // Orange
};

////////////////////////////////////////////////////////////////////////////////
// Grab Canvas & Context
////////////////////////////////////////////////////////////////////////////////
const canvas = document.getElementById("chessCanvas");
const ctx = canvas.getContext("2d");

// Overlays
const menuScreen = document.getElementById("menuScreen");
const instructionsScreen = document.getElementById("instructionsScreen");
const colorScreen = document.getElementById("colorScreen");
const difficultyScreen = document.getElementById("difficultyScreen");
const gameOverScreen = document.getElementById("gameOverScreen");
const gameOverText = document.getElementById("gameOverText");

let gameState = "menu";

////////////////////////////////////////////////////////////////////////////////
// Chess and State Variables
////////////////////////////////////////////////////////////////////////////////
const chess = new Chess();  // from chess.js

// We'll store images in a "pieces" object
const pieces = {};
const pieceNames = ["king","queen","rook","bishop","knight","pawn"];
const pieceColors = ["white","black"];

let selectedSquare = null;
let legalMoves = [];
let lastMove = null;
let playerColor = null;
let difficulty = null;

////////////////////////////////////////////////////////////////////////////////
// Minimax-like AI (medium/hard)
////////////////////////////////////////////////////////////////////////////////
const PIECE_VALUES = { p: 1, n: 3, b: 3, r: 5, q: 9, k: 0 };

function evaluateBoard(chessInstance) {
  if (chessInstance.isGameOver()) {
    if (chessInstance.inDraw() || chessInstance.inStalemate()) return 0;
    return chessInstance.turn() === 'w' ? -9999 : 9999;
  }
  return chessInstance.board().reduce((score, row) => {
    return score + row.reduce((rowScore, piece) => {
      if (!piece) return rowScore;
      let value = PIECE_VALUES[piece.type];
      return rowScore + (piece.color === 'w' ? value : -value);
    }, 0);
  }, 0);
}

function minimax(chessInst, depth, alpha, beta, maximizing, endTime) {
  if (depth === 0 || chessInst.isGameOver() || Date.now() > endTime) return evaluateBoard(chessInst);
  let moves = chessInst.moves({ verbose: true });

  if (maximizing) {
    let value = -Infinity;
    for (let m of moves) {
      chessInst.move(m);
      value = Math.max(value, minimax(chessInst, depth - 1, alpha, beta, false, endTime));
      chessInst.undo();
      alpha = Math.max(alpha, value);
      if (beta <= alpha) break;
      if (Date.now() > endTime) break;
    }
    return value;
  } else {
    let value = Infinity;
    for (let m of moves) {
      chessInst.move(m);
      value = Math.min(value, minimax(chessInst, depth - 1, alpha, beta, true, endTime));
      chessInst.undo();
      beta = Math.min(beta, value);
      if (beta <= alpha) break;
      if (Date.now() > endTime) break;
    }
    return value;
  }
}

function findBestMove(chessInst, depth, maxTime) {
  let bestMove = null;
  let bestValue = -Infinity;
  const endTime = Date.now() + maxTime;
  let moves = chessInst.moves({ verbose: true });

  moves.sort(() => Math.random() - 0.5);

  for (let m of moves) {
    if (Date.now() > endTime) break;
    chessInst.move(m);
    let val = minimax(chessInst, depth - 1, -Infinity, Infinity, false, endTime);
    chessInst.undo();
    if (val > bestValue) {
      bestValue = val;
      bestMove = m;
    }
  }
  return bestMove || moves[0] || null;
}

function getAIMove(difficultyStr, chessInst) {
  let moves = chessInst.moves({ verbose: true });
  if (moves.length === 0) return null;
  if (difficultyStr === "easy") return moves[Math.floor(Math.random() * moves.length)];
  return findBestMove(chessInst, difficultyStr === "medium" ? 2 : 4, difficultyStr === "medium" ? 4000 : 8000);
}

////////////////////////////////////////////////////////////////////////////////
// Board => Screen transformations
////////////////////////////////////////////////////////////////////////////////
function boardToScreen(row, col) {
  return playerColor === 'w' ? { sr: 7 - row, sc: 7 - col } : { sr: row, sc: col };
}

function screenToBoard(sr, sc) {
  return playerColor === 'w' ? { r: 7 - sr, c: 7 - sc } : { r: sr, c: sc };
}

////////////////////////////////////////////////////////////////////////////////
// Click Handling & AI Turn
////////////////////////////////////////////////////////////////////////////////
canvas.addEventListener("mousedown", (e) => {
  if (gameState !== "playing") return;
  
  const rect = canvas.getBoundingClientRect();
  let { r, c } = screenToBoard(Math.floor((e.clientY - rect.top) / SQUARE_SIZE), Math.floor((e.clientX - rect.left) / SQUARE_SIZE));
  let square = String.fromCharCode(97 + c) + (8 - r);

  if (!selectedSquare) {
    let piece = chess.get(square);
    if (piece && piece.color === chess.turn()) {
      selectedSquare = square;
      legalMoves = chess.moves({ verbose: true }).filter(m => m.from === square);
    }
  } else {
    let move = legalMoves.find(m => m.to === square);
    if (move) {
      chess.move(move);
      lastMove = move;
      selectedSquare = null;
      legalMoves = [];
      if (chess.isGameOver()) return showGameOver();
      setTimeout(aiTurnIfNeeded, 500);
    } else {
      selectedSquare = null;
      legalMoves = [];
    }
  }
});

function aiTurnIfNeeded() {
  if (chess.turn() !== playerColor) {
    const ai_move = getAIMove(difficulty, chess);
    if (ai_move) chess.move(ai_move);
    if (chess.isGameOver()) showGameOver();
  }
}

////////////////////////////////////////////////////////////////////////////////
// Game Over
////////////////////////////////////////////////////////////////////////////////
function showGameOver() {
  gameState = "game_over";
  gameOverText.textContent = chess.inCheckmate() ? (chess.turn() === 'w' ? "Black Wins!" : "White Wins!") : "Draw!";
  gameOverScreen.style.display = "flex";
}

////////////////////////////////////////////////////////////////////////////////
// Start Game
////////////////////////////////////////////////////////////////////////////////
document.getElementById("newGameBtn").onclick = () => gameState = "color_choice";
document.getElementById("whiteSideBtn").onclick = () => { playerColor = 'w'; gameState = "difficulty_choice"; };
document.getElementById("blackSideBtn").onclick = () => { playerColor = 'b'; gameState = "difficulty_choice"; };
document.getElementById("easyBtn").onclick = () => { difficulty = "easy"; gameState = "playing"; chess.reset(); };
document.getElementById("mediumBtn").onclick = () => { difficulty = "medium"; gameState = "playing"; chess.reset(); };
document.getElementById("hardBtn").onclick = () => { difficulty = "hard"; gameState = "playing"; chess.reset(); };
document.addEventListener("keydown", (e) => { if (e.key.toLowerCase() === "m") gameState = "menu"; });

////////////////////////////////////////////////////////////////////////////////
// Start Loop
////////////////////////////////////////////////////////////////////////////////
requestAnimationFrame(() => { if (gameState === "playing") redrawPlayingScreen(); });
